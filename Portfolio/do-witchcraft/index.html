<!--
    Welcome to my website!
    If you're seeing this message on the dev console, 
    then you must be here to find which font I used.
    Feel free to grab that right below :D
    - Gavin_

    Hosted at: github.com/SilvRHat/gzimm4.github.io
-->
<!DOCTYPE html>
<html>
    <head>
        <title>Do Witchcraft</title>
        <link rel="icon" href="../../favicon.ico">
        <link rel="stylesheet" href="../../style.css">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300&family=Noto+Serif+JP:wght@300;400&family=Shippori+Mincho&display=swap" rel="stylesheet">
    </head>
    <body>
        <!-- HEADER -->
        <div class="navbar">
            <a class="home" href="../..">
                <h1>Gavin Zimmerman<img class='logo' src="../../img/logo.png"></h1>
                <h2>Technical Art · Direction // Programming</h2>
            </a>
            <div class="content">
                <div class="dropdown">
                    <a href=""><h3>Tech Art</h3></a>
                    <div class="dropdown-content">
                        <a href="../do-witchcraft/">Do Witchcraft</a><br>
                        <a href="../Ukiyo/">Project::Ukiyo「浮世」</a><br>
                        <a href="../grav-flux/">Gr@v:f/UX</a><br>
                        <a href="../blackhole/">BlackH01e</a><br>
                        <a href="../SPdr/">SP//dr_wbs</a><br>
                        <a href="../Ramen/">Tech·Katsu:Ramen</a><br>
                    </div>
                </div>
                <div class="dropdown">
                    <a href=""><h3>Project</h3></a>
                    <div class="dropdown-content">
                        <a href="../MvRE/">Mv:RE(Rendering Engine)</a><br>
                        <a href="../noir/">Noir~ Game</a><br>
                        <a href="../Diced/">Diced</a><br>
                        <a href="../light-stealer/">Light Stealer</a><br>
                    </div>
                </div>
                <div class="dropdown">
                    <a href="../../Profile/"><h3>Profile</h3></a>
                </div>
                <div class="dropdown">
                    <a href="../../Archive/"><h3>Archive</h3></a>
                </div>
            </div>
        </div>

        <!-- COVER -->
        <div class="cover-fit">
            <img src="cover.png">
            <div class="vert_title">
                <h2 style="color:white;">Do Witchcraft</h2>
            </div>
        </div>


        <!-- MAIN -->
        <div class="scroll">
            <!-- youtube -->
            <div class="content-2">
                <div class="info-box">
                    <h2>Do Witchcraft</h2>
                    <img><br>

                    <table style="text-align: center; margin: auto;">
                        <tr>
                            <td><strong>Producers:</strong></td>
                            <td><small>Gavin Zimmerman</small></td>
                        </tr>
                        <tr>
                            <td><strong>Developed:</strong></td>
                            <td><small>May 2022 - June 2022</small></td>
                        </tr>
                        <tr>
                            <td><strong>Media:</strong></td>
                            <td><small>Realtime VFX</small></td>
                        </tr>
                        <tr>
                            <td><strong>Tech:</strong></td>
                            <td><small>Blender 3.2</small></td>
                        </tr>
                        <tr>
                            <td><strong>Links:</strong></td>
                            <td><small>N/A</small></td>
                        </tr>
                    </table>

                    <h3>Table of Contents</h3>
                    <ul>
                        <li><a href="#project">Do Witchcraft</a>
                            <ul>
                                <li><a href="#video">Video</a></li>
                                <li><a href="#about">About</a></li>
                            </ul>
                        </li>
                        <li><a href="#breakdown">Breakdown</a>
                            <ul>
                                <li><a href="#vfx">VFX Storyboards</a></li>
                                <li><a href="#material">Material Shaders</a></li>
                                <li><a href="#glyphs">Glyph Shaders</a></li>
                                <li><a href="#geom">Procedural Geometry</a></li>
                                <li><a href="#anim_set">Animation Setup</a></li>
                                <li><a href="#anim_bd">Animation Breakdown</a></li>
                                <li><a href="#render">Rendering</a></li>
                            </ul>
                        </li>
                    </ul>
                </div>
                <h1 id="project">Do Witchcraft</h1>
                <div id="video" class="project-reel">
                    <iframe style="aspect-ratio: 560/315; width: 100%;" src="https://www.youtube.com/embed/_1Ni1kh8UYo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                </div>

                <h2 id="about">About</h2>
                Do Witchcraft is a personal project exploring SDFs, bezier curves, animation curves,
                procedural geometry, timing, and of course magic. The concept behind the magic spells is taken from "The Owl House"
                animation series by Dana Terrace and produced by Disney Television Animation.
                <br><br>
                Each card contains a glyph/symbol on them responsible for performing a spell,
                with four base symbols for: light, ice, plant, and fire magic.
                <br><br>
                These effects are created entirely procedurally from modeling to animation to texturing. 

                <h1 id="breakdown">Breakdown</h1>
                As with all my projects, I've included a detailed breakdown behind the making of this animation.
                This writeup is a collection of design choices, technical methods, code, concept images, mathmatical notes and designs, and everything inbetween.
                <br><br>
                At the bottom is a new section on rendering workflow - describing what went wrong in early renders and how iterations built up the final animation here.
                <br><br>
                If you as a reader have any questions about the process or content here then please don't hesitate to ask.
                <br><br>


                <h2 id="vfx">VFX Storyboards</h2>

                <br><br>
                <img class="img-border" style="width:calc(45% - 10px);" src="img/light-st.png">
                <p class="img-id">1</p>
                <div style="display: inline-block; width: 5%;"></div>
                <img class="img-border" style="width:calc(45% - 10px);" src="img/ice-st.png">
                <p class="img-id">2</p>
                <br><br>
                <img class="img-border" style="width:calc(45% - 10px);" src="img/plant-st.png">
                <p class="img-id">3</p>
                <div style="display: inline-block; width: 5%;"></div>
                <img class="img-border" style="width:calc(45% - 10px);" src="img/fire-st.png">
                <p class="img-id">4</p>

                <ol>
                    <li>Storyboard/ Notes for Light Spell</li>
                    <li>Storyboard/ Notes for Ice Spell</li>
                    <li>Storyboard/ Notes for Plant Spell</li>
                    <li>Storyboard/ Notes for Fire Spell</li>
                </ol>

                Drawing quick storyboards for each effect proved to be very useful conceptualizing the work to be done.
                Each board includes components of the effect, a timing reference (primary action for animation), and initial procedural design ideas.
                <br>
                Not all initial ideas (such as particles on the flower) made it into the final version, nor did the final version only have initial ideas.

                <h2>Material Shaders</h2>
                <img style="width: 99%;" src="img/materials.png">
                <p class="img-id">1</p>
                <br><br>

                There are a total of 15 shaders for the background, magic cards, eyeball dial thing, and elemental materials.
                This section covers the making of those elemental materials and the eyeball. I also reference notes on geometry,
                as geometric shape plays an important part in each material - they are not simply UV dependent.
                
                <h3>Eyeball</h3>
                The dial object with the eyeball printed on it wasn't thought of until halfway through the formal rendering process. In fact,
                it was completely coded while another computer was working on the latest render to see if the concept would even fit.
                <br><br>
                The shader setup is relatively simple, two principled BSDFs (Blender's PBR shader) were mixed together by a "blinking" factor (boolean). 
                These BSDF's were configured to look like metal and an eyeball by adjusting specular, metallic, clearcoat, roughness, and emissive parameters.
                <br><br>
                <img style="width: 35%;" src="img/metal-nd.png">
                <p class="img-id">2</p>
                <img style="width: 61%;" src="img/eye-nd.png">
                <p class="img-id">3</p>
                <br><br>
                <ol>
                    <li>Materials on Sphere</li>
                    <li>Metal Shader</li>
                    <li>Eyeball Shader</li>
                </ol>

                For simplicity, the blinking animation is driven by the frame number. 
                The animation started off as periodic, where the frame was divided by the frequency (frames per blink). 
                The fraction component of this value has then shaped like an absolute triangle wave, and then into thin spikes. 
                This was used as a space multiplier, which is then passed into a 3D space multiplier which affects the result of a length comparison which is then used as the factor.
                1D voronoi noise is added so to the frame input to offset each blink into a semi-random cycle. 
                <br><br>
                <img style="width: 99%;" src="img/blink-nd.png">
                <p class="img-id-side">4</p>
                <img style="width: 99%;" src="img/blink2-nd.png">
                <p class="img-id-side">5</p>
                <br><br>
                <ol start="4">
                    <li>Shaping Time into blink signals; final power node is number of units to multiply X-axis space by</li>
                    <li>Checking length to shape eyelids; note maximum is used such that if the blink signal is at its max value then all everything is eyelid</li>
                    <li>Light parented to eyeball for custom specular reflection</li>
                </ol>
                Finally, a small light was parented the the eye for the custom specular. 
                <br><br>
                <img style="width: 50%;" src="img/eye-spec.png">
                <p class="img-id">6</p>



                
                

                <h3>Ice</h3>
                The ice material makes some assumptions about the geometry - in that it expects the geometry to be shaded flat and for vertices to be sparse.
                <br><br>
                For the actual geometry, noise is added/subtracted along the normals of vertices on a detailed object. 
                The object is then tesselated to lower detail (and vertices).
                <br><br>

                As far as shading, the layers/blending get pretty fun here.
                <br><br>

                <img style="width: 24%;" src="img/ice-m1.png">
                <p class="img-id">1</p>
                <img style="width: 21%;" src="img/ice-m2.png">
                <p class="img-id">2</p>
                <img style="width: 51%;" src="img/ice-r-1-2.png">
                <p class="img-id">3</p>
                <br><br>
                <ol>
                    <li>The base color is driven by noise from the normal</li>
                    <li>Refraction color is blended with base color</li>
                    <li>Node network of 1 + 2</li>
                </ol>

                This covers the base diffuse color.
                For scratches and extra details, we'll blend in some distored wave texture with a fresnel.
                <br><br>
                <img style="width: 32%;" src="img/ice-ma.png">
                <p class="img-id">4</p>
                <img style="width: 32%;" src="img/ice-mb.png">
                <p class="img-id">5</p>
                <img style="width: 32%;" src="img/ice-mab.png">
                <p class="img-id">6</p>
                <br><br>
                <img style="width: 60%;" src="img/ice-ab-nd.png">
                <p class="img-id">7</p>
                <br><br>
                <ol start="4">
                    <li>Fresnel Blending Value</li>
                    <li>Distored Wave Texture</li>
                    <li>Fresnel on Distorted Wave</li>
                    <li>Node Setup</li>
                </ol>
                The fresnel effect is to emphasize the scratches on surfaces pointing away from the camera, as is the case
                in reality.
                <br><br>
                The final touches involve noding this scratched ice look into a shader which processes scene lighting info.
                The ice ejects from an emissive surface, so adding some emission at the bottom may be nice. Here, this emission
                is also multiplied with the value of the base color.
                <br><br>
                <img style="width: 23%;" src="img/ice-e1.png">
                <p class="img-id">8</p>
                <img style="width: 24%;" src="img/ice-e2.png">
                <p class="img-id">9</p>
                <img style="width: 50%;" src="img/ice-full-nd.png">
                <p class="img-id">10</p>
                <br><br>
                <ol start="8">
                    <li>Value derived from up axis</li>
                    <li>Emission</li>
                    <li>Full Node Tree</li>
                </ol>

                <h3>Flower; Stem, Leaf, and Petal</h3>
                The flower materials unlike the others are UV driven materials, 
                meaning that instead of 3D coordinates a 2D UV Map is required here. 
                This is important to point out, because it can be difficult to reuse these materials across multiple objects.
                Yet, that isn't a concern here as leaves generally look alike (and we're not in a production environment).
                <br><br>
                The most difficult bit with these materials is color and lighting. 
                It's really something you need to go outside and study and maybe draw a brief sketch to feel out the colors.<br><br>
                <img style="width: 50%;" src="img/plant-color-study.png">
                <p class="img-id">1</p>
                <br><br>
                <ol>
                    <li>Color Study</li>
                </ol>
                Similar to human skin, plants have layers of material which are translucent or semi-transparent. 
                Light passes through these layers, bounces, a while, and exits which is known as subsurface scattering.
                
                
                <br><br>
                <img style="width: 35.5%;" src="img/no-ss.png">
                <p class="img-id">2</p>
                <img style="width: 40%;" src="img/ss.png">
                <p class="img-id">3</p>
                <br><br>
                <ol start="2">
                    <li>Without Subsurface Scattering</li>
                    <li>With Subsurface Scattering</li>
                </ol>
                Notice that the shadows are much softer in subsurface scattering. 
                By altering which color is allowed to pass best through subsurface scattering, this smooth taper can have a color gradient.
                The detault is set to a reddish hue, however here I found that a blue green one to best reflect what I observed in nature.
                
                For the details on the leaf, it is largely shuffling with the UV map space. 
                X and Y make up the depth and width of the leaf respectively. 
                Rotating this space toward the center, provides a useful coordinate system for the veins of the leaf. 
                <br><br>
                <img style="width: 18%;" src="img/leaf1.png">
                <p class="img-id">4</p>
                <img style="width: 18%;" src="img/leaf2.png">
                <p class="img-id">5</p>
                <img style="width: 18.5%;" src="img/leaf3.png">
                <p class="img-id">6</p>
                <img style="width: 19%;" src="img/leaf4.png">
                <p class="img-id">7</p>
                <img style="width: 19%;" src="img/leaf5.png">
                <p class="img-id">8</p>
                <br><br>
                <img style="width: 70%;" src="img/voronoi-secret.png">
                <p class="img-id">9</p>
                <br><br>
                <ol start="4">
                    <li>Rotated Space with Voronoi for distance from vein</li>
                    <li>SDF from Stem</li>
                    <li>Smooth Minnimum of 4 and 5</li>
                    <li>Remapped Values</li>
                    <li>Value mapped to Color Ramp</li>
                    <li>Nodes for getting vein SDF</li>
                </ol>

                The petals are similar, but are naturally less patterned. 
                The node setup for this one is realtively small, though had not initially been. 
                This setup, although lacking an eloquent method, matches detail with the rest of the scene and fits within the color scheme.
                <br><br>

                <img style="width: 24.1%;" src="img/petal1.png">
                <p class="img-id">10</p>
                <img style="width: 24.5%;" src="img/petal2.png">
                <p class="img-id">11</p>
                <img style="width: 23%;" src="img/petal3.png">
                <p class="img-id">12</p>
                <img style="width: 23%;" src="img/petal4.png">
                <p class="img-id">13</p>
                <br><br>
                <img style="width: 97.5%;" src="img/petal-nd.png">
                <p class="img-id">14</p>
                <br><br>
                <ol start="10">
                    <li>Noise</li>
                    <li>Voronoi with noise added onto coordinates</li>
                    <li>Remapped values for greater contrast</li>
                    <li>Color Ramp</li>
                    <li>Full shader tree for petals</li>
                </ol>

                <h3>Fire</h3>
                The ways for making fire are limitless.<br><br>
                The most common approach involves passing in some fire texture to a particle emitter and shaping the particles motion path
                to look like fire. 
                There are also fire simulation technology similar to fluid simulation- which might use a volume or surface shading technique.
                <br><br>
                This approach however assumes the geometry for our fire is a mesh (mostly) in the shape of fire. 
                For this section, I will use a sphere to breakdown the fragment shader.
                <br><br>
                To create this fire visual, I especially wanted to recreate the look of calcifer from Howl's Moving Castle by Studio Ghibli.
                I imagined this would pair well with the existing animations which had all already been completed.
                <br><br>
                <img style="width: 60%;" src="https://c.tenor.com/o7St1LoMu1MAAAAC/calcifer-studio-ghibli.gif">
                <p class="img-id">1</p>
                <img style="width: 34%;" src="img/fire-study.png">
                <p class="img-id">2</p>
                <br><br>
                <ol>
                    <li>Calcifer</li>
                    <li>Color/blending study</li>
                </ol>
                A key component in fire is the tendrils which move up along the edge of the shape. 
                This is actually very difficult to create well in a 3D setting opposed to a 2D setting, due to variation in perpsective.
                However, a custom fresnel effect and some noise can get pretty close to creating the effect.
                <br><br>
                <img style="width: 19%;" src="img/fire1.png">
                <p class="img-id">3</p>
                <img style="width: 19%;" src="img/fire2.png">
                <p class="img-id">4</p>
                <img style="width: 19%;" src="img/fire3.png">
                <p class="img-id">5</p>
                <img style="width: 19%;" src="img/fire4.png">
                <p class="img-id">6</p>
                <img style="width: 19%;" src="img/fire5.png">
                <p class="img-id">7</p>
                <br><br>
                <img style="width: 50%;" src="img/fire-alpha.gif">
                <p class="img-id">8</p>
                <br><br>
                <ol start="3">
                    <li>Normal</li>
                    <li>Normal blended with driven noise</li>
                    <li>Fresnel with new normal (dot with camera)</li>
                    <li>Remapped values</li>
                    <li>Flipped values/ Remapped More</li>
                    <li>Noise moves along Z (up) axis, to drive the tendrils up</li>
                </ol>

                This mask is now the alpha value or transparency of the fire. 
                And the same trick is used for each layer of color, using different mixes of noise. 
                The middle color barely mixes any noise into the normal. 
                I also plugged in an exponent operation here to customize the falloff of the fresnel effect.
                <br><br>
                <img style="width: 22%;" src="img/fire-orangered.png">
                <p class="img-id">9</p>
                <img style="width: 23%;" src="img/fire-yellow.png">
                <p class="img-id">10</p>
                <img style="width: 50%;" src="img/fire-bd.png">
                <p class="img-id">11</p>
                <br><br>
                <ol start="9">
                    <li>Blend between Dark Red/Pink (Outer) and Orange (Middle)</li>
                    <li>Yellow (Inner)</li>
                    <li>Node Breakdown</li>
                    <li>Blended Colors</li>
                    <li>Color with Transparency</li>
                </ol>
                Working with the colors here required a live render/viewing with the final shader output which was responsible for emission.
                Emission would blow up the darker colors to brighter and more contrast values- so getting this right required a bit of fine tuning.
                <br><br>
                <img style="width: 40%;" src="img/fire-color.gif">
                <p class="img-id">12</p>
                <img style="width: 46%;" src="img/fire-mat.gif">
                <p class="img-id">13</p>

                <h2>Glyph Shaders</h2>
                <img style="width: 99%;" src="img/sdf.png">
                <p class="img-id">1</p>
                <br><br>
                To be written :)
                
                <!---
                <h2 id="sdf">Magic Card SDFs</h2>
                This first step is to create the cards themselves. 
                The geometry here is fairly simple - and only requires a plane (which may be subdivided later for deforming the card).
                Thus, the first major challenge is to texture the glyph pattern onto each card.
                <br><br>
                Because each glyph pattern features only simple geometry (line, circle, triangle, quadratic bezier curve, etc), we can generate SDFs mathematically to represent the patterns.
                An SDF is a signed distance field, where each position or fragment (in glsl terms) holds a signed value. 
                The values of every position make up a field, which then can make up a shape. For example a voronoi texture is an SDF representing the distance to the closest points.
                <br><br>
                SDF's may also be combined with maximum and mimimum operations for intersections and unions.
                So from SDFs of circles, lines, (quad) bezier curves, and triangles we'll be able to generate a SDF for the glyph patterns.
                <br><br>
                <img width="99%" src="img/sdf.png">
                <br><br>
                For this breakdown, I'll touch on the making of the Ice glyph (second from the left).

                <h3>Circle SDF</h3>
                The SDF for a circle is very simple - it is simply the length from the circle's center. 
                However, we want this SDF to be hollow. This can be done by subtracting the radius of the circle and then taking the absolute value of that.
                What happens is at radius R where the SDF value would be equal to R, after the subtraction the value is then 0. 
                Taking the absolute value, then inverses the inner part of the circle so that its positive.
                <br><br>
                <img width="99%" src="img/circle-sdf.png">
                <br><br>
                The center here so happens to be at (0,0) - but using the distance operation instead of the length operation can be used to offset the circle.
                <br><br>
                <h3>Rectangle SDF</h3>
                For the rotated square in the middle, I use a rectangle SDF since it allows for easier customization over 4 line SDFs.
                This is also fairly simple and demonstrates the technique for combining SDFs. 
                <br><br>
                For customization, we let the SDF function take in parameters for width and height. 
                For positioning, lets assume the center is always at (0,0) - the passed in coordinates to this SDF function can be changed to offset its location.
                <br><br>
                Now similar to the circle, 0 should be the value at each edge. The idea is to do this for each edge - which is simply offsetting the coordinate system 4 ways.
                Maximum operations can then be used for unioning.
                <br><br>
                <img width="23%" src="img/r0.png">
                <img width="24%" src="img/r1.png">
                <img width="23%" src="img/r2.png">
                <img width="23%" src="img/r3.png">
                <br><br>

                <h3>Line SDFs (simple and quadratic bezier)</h3>
                Some SDFs are significantly more mathmatical. 
                A line with rounded edges for example has 3 different cases for what the distance may be - and a bezier curve is a bezier curve.
                Luckily, such mathematical functions are readily available on the <a tagrte="_blank" href="https://iquilezles.org/articles/distfunctions/">internet</a>.
                Just be prepared to transcribe glsl code to blender nodes - which may only be readble in mathmatical notation.
                <br><br>
                <img width="96%" src="img/bezier-sdf.png">
                <br><br>
                <h3>Putting it together</h3>
                To union SDFs, a minimum operation may be used. A smooth minimum operation can also result in smooth combinations of SDFs.
                For organization of the whole SDF into a readable node tree, we have the coordinate system (middle purple line) and distance field (middle grey line)
                pass through the entire tree where they are used as inputs and updated from outputs.
                <br><br>
                <img width="96%" src="img/nodes.png">
                

                
                <br><br><br>
                <h2 id="lm">Light Magic</h2>
                The first magic VFX is the light magic spell, which generates a ball of floating light.
                
                <br><br>
                <h3 id="l-concept">Concept Breakdown</h3>
                The light spell works by transforming the piece of paper the glyph is written on into a ball of light.
                The tranformation of geometry from a plane into a sphere cause the paper to look like its crumbling into a ball- whilst
                simultaneously emitting more and more light. The ball then levitates in the air - thus when the paper first starts crumbling
                it has already started levitating somewhat.
                <br><br>
                Below is a simple VFX storyboard. The left-most column is time, the next column is the frame, and then notes are placed on the right.
                <br><br>
                <img width="40%" src="img/light-st.png">

                
                <br><br>
                <h3 id="l-frag">Shaders (Fragment)</h3>
                There are two pieces of geometry to shader here- the paper and the ball of light. 
                Shaders or materials can often be a limited resource in game development; so allocating two materials here may be overkill in some contexts.
                This is just something to be aware of in practice, but not constrained here.
                <br><br>
                The light material is simply an emission material and nothing more (which may be used for many lit objects in a game).
                <br><br>
                For the paper, there is a bit more work here.
                <br>
                First, on creating the paper texture - the UV map is plugged into a 2D noise texture. 
                Note that the node here actually uses the 2D setting instead of the default 3D input which is more computationally expensive.
                The factor of this texture is then plugged into a color ramp.
                <br><br>
                This noise is then reused and overlayed (added) onto the glyph SDF mentioned in the earlier section. 
                A comparison operation is then used as a factor in blending the paper color and ink color.
                <br><br>
                <img width="99%" src="img/light1.png">
                <br><br>
                For the emission, we need some concept of time so that the emission can be applied at the correct time.
                We also want some easy way of mapping time to values.
                <br><br>
                For time, we'll create a uniform (attribute in blender)- how this is set will be explained in the geometry section (since it has to be done on the CPU side).
                For mapping time to values, we'll construct a setup of two map range nodes and a float curve.
                The float curve allows values to be customized (since these are animating the effects we want to be able to ease the effects via curves).
                The mapping ranges are then placed around this to map the time range to the float curve input and then remap its outputs correctly.<br><br>
                To organize all this, I created a group node which does no operations but makes hooking the nodes together easier.
                <br><br>
                <img width="99%" src="img/light2.png">
                <br><br>
                That wraps up the shaders for this effect - the next piece is animating the paper crumbling into a ball.

                <br><br>
                <h3 id="l-geom">Geometry</h3>
                The geometry trees for this project get quite big.
                <br><br>
                <img width="99%" src="img/big-geom.png">
                <br><br>
                So I've included a list of what is animated (components which change) as a simple breakdown. 
                The following text then iterates more on each animated value and component.
                <ul>
                    <li>Curve on edges
                        <ul>
                            <li>Radius of curve</li>
                            <li>How much of the edge is curved (factor)</li>
                        </ul>
                    </li>
                    <li>Crumble (Noise Height offset)
                        <ul>
                            <li>Amplitude</li>
                            <li>Roughness (Distortion)</li>
                        </ul>
                    </li>
                    <li>Float
                        <ul>
                            <li>Float Height</li>
                            <li>Oscillation Amount</li>
                        </ul>
                    </li>
                    <li>Scale of the big sphere</li>
                    <li>Particles
                        <ul>
                            <li>Scaling</li>
                            <li>Distance away</li>
                        </ul>
                    </li>
                </ul>
                <br><br>

                Before all else, in the geometry step we need to create the notion of a timeline as mentioned in the previous section.
                To do this, we use the Z coordinate of an empty (middle) parented under our light 3D object. This node tree (left) is the leftmost in our geometry tree,
                since we also use this value to animate the geometry. After which, it is mapped to an attribute in the modifier settings. 
                To do this, you must also create an attribute- which ultimately acts as a uniform to the shader (right).
                <br><br>
                <img width="52%" src="img/time-nodes.png">
                <img width="14%" src="img/empty.png">
                <img width="33%" src="img/mods.png">

                <br><br>
                Now onto deformation.
                <br><br>
                To properly deform the mesh, first we need vertices to represent the amount of detail we're looking for. 
                The default 4 will not cut it, thus the very first operation is to subdivide the mesh.
                <br><br>
                <img width="35%" src="img/g1.png">
                <br><br>
                Next we want to crumble the edges of the plane inwards. To start, lets design a 2D test model.
                <img width="99%" src="img/lg2.png">
                <br><br>
                Basically, we'll start by curving the end around some arbitrary circle. 
                The circle's size and where curving begins is animated, which allows for customization.
                <br><br>
                Our 3D scenario translates easily to our 2D model - we can consider the X value in the 2D model as the distance from the center of our paper geometry.
                The up value then doesn't change. 
                <br><br>
                Next, we must define where the circle (or curvature) begins. 
                To do this, we constrain the max X value in the 2D model it can be placed. 
                This is equal to the distance of the corners from the center - which is 1.7 here.
                <br><br>
                Next we create an animatable parameter which is the factor along this length that the circle is placed.
                Using the vertex position, we then want to find how much is curved and how much is flat of its distance from the center.
                <br><br>
                <img width="99%" src="img/node-bd1.png">
                <br><br>
                Next, we want to get the radius which is also animatable. For this parameter, the circumfrence may actually make more sense in terms of units and values
                since the paper is wrapped around the surface of the circle. 
                The animation parameter I use here is called 'curvature' and translates to how many radians the max length is wrapped up in. 
                So if its 2π, that mean wrapping the max length 1.7 will give a complete circle.
                <br><br>
                The amount its curved by can then be divided by the total length and multiplied by this parameter to get the angle to rotate by.
                <br><br>
                Rotation here is done by axis angle, where the axis is the in/out axis of our 2D model. 
                The rotated vector is at (0,0) and the center is at (0, radius). Afterwards, the flat component is added to produce the final position in the 2D model space.
                <br><br>
                <img width="99%" src="img/geom-bd2.png">
                <img width="99%" src="img/geom-bd3.png">
                <br><br>
                Next, we have to put this in 3D space via another axis angle rotation. 
                This time the axis is the up vector, the center is (0,0), and the vector rotated in the result of the 2D model above. 
                The angle is determined via an azimuth angle generated from the oiginal position.
                <br><br>
                <img width="66%" src="img/geom-bd4.png">
                <img width="30%" src="img/geom-bd5.png">
                <br><br>
                Next, we add some noise to get a more realistic crumble. 
                For noise, we use the initial position and add the scene time to the Z axis - this lets the noise change over time.
                For animation parameters we want to animate: how much noise is applied, and how rough the noise is (change distortion).
                You'll also see there is an animation for the floating height in the following screenshot - this is done to condense
                setting the position once.
                <br><br>
                <img width="99%" src="img/geom-bd6.png">
                <br><br>
                There's also a related animation for how much to apply the oscillation effect.
                <br><br>
                <img width="70%" src="img/geom-bd7.png">
                <br><br>
                For other geometry, the instance on points geometry node is used to instance exisiting 3D models such as a glowing sphere.
                That geometry is then joined with the exisiting plane geometry and used as the final output geometry.
                <br><br>
                <img width="70%" src="img/geom-bd8.png">
                <br><br>
                For particles, random values are generated and used for direction, scale multiplier, and a distance multiplier.
                <br><br>
                <img width="50%" src="img/geom-bd9.png">                
                <br><br>
                And thats the first effect.
            -->




                <br><br><br>
                <!--
                <h2 id="lm">Plant Magic</h2>
                <h3 id="p-concept">Concept Breakdown</h3>
                <h3 id="p-frag">Shaders (Fragment)</h3>
                <h3 id="p-geom">Geometry</h3>
                <h2 id="lm">Fire Magic</h2>
                <h3 id="f-concept">Concept Breakdown</h3>
                <h3 id="f-frag">Shaders (Fragment)</h3>
                <h3 id="f-geom">Geometry</h3>
                -->

                <h2>Rendering</h2>
                This section is fairly unique across my projects and explains what I did between test renders, what I thought could be improved, why, and how I attempted to correct it in the next iteration.
                I think this skill is especially important to demonstrate - as it gives some context in how one spots short-comings and handles them.
                <br><br>
                The timeline for this project largely put rendering towards the very end. 
                The majority of time was spent making each VFX look great in realtime and not until each effect was done had I thoroughly
                explored composition, layout, camera animation, background, etc. 
                Thus, rendering was in a short enough timeline that documenting a comprehensive outline on this iterative process was very easy.
                <br><br>
                
                <h3>Roughly Halfway</h3>
                <video controls width="80%;" src="witchcraft-6-1-progress.mov"></video>
                <br><br>
                First, here is an early screen recording of the development process. 
                You can see that I'm currently working on the plant animation. 
                The general process was to create the magic card, then animate the geometry, then color that geometry, and return to animating the geometry with color, and repeating.
                <br>

                <h3>First Render</h3>
                <video controls width="80%;" src="witch-render-1.mp4"></video>
                <br><br>
                Here's what I thought wasn't great:
                <ul>
                    <li>The light is just a bit overscaled compared to the other animations</li>
                    <li>The splash on the ice dissipates to quick</li>
                    <li>The stem color on the flower was too faded (same with leaf)</li>
                    <li>The subsurface radius/color did not match the petal colors at all</li>
                    <li>Petals are overdetailed compared to other components</li>
                    <li>The edges on the fire had to much fade and the noise on these edges was to fine and the moving of this noise was to fast</li>
                </ul>
                <br>

                <h3>Second Render</h3>
                <video controls width="80%;" src="witch-render-20001-0600.mp4"></video>
                <br><br>
                Thoughts:
                <ul>
                    <li>Shadows on light card are really not great during the crumble</li>
                    <li>Ice animation in now too long - notice flicker at end</li>
                    <li>The color here could also be stronger</li>
                    <li>The fire big explosion is a bit to fast</li>
                </ul>

                <h3>Third Render</h3>
                <video controls width="80%;" src="witch-render-30001-0600.mp4"></video>
                <br><br>
                Thoughts:
                <ul>
                    <li>Ice splash is still wonky (doesn't fade soon enough this time)</li>
                    <li>Light animation is still a bit too large</li>
                </ul>

                <h3>Fifth Render</h3>
                <video controls width="80%;" src="witch-render-60001-0600.mp4"></video>
                <br><br>
                After the fifth render, I was fairly happy with the effects and started working on camera animation and overall turning this into a video 
                for showcasing the animations as a collection. I also added a soft gradient to the background.
                <br><br>
                I really liked the spin and circular framing; for some reason it held onto the theme of magic. 
                Maybe because SOOOO many representations of magic use circles? 
                Maybe the camera emphasized passing on the torch from one animation to the next and added some cohesive element.
                <br><br>
                And then I published this version to youtube, because I thought I hit the top as far what I could do. 
                But I wasn't very happy with this result - working with each animation individually had a lot of feeling and was very exciting to see come together. 
                Yet, together there wasn't feeling in it. 
                The context of each animation in an environment was dull. Simply playing the animation wasn't enough,
                there had to exist a reason or context for it to play.
                <br><br>
                In the Art book of Howl's Moving Castle by Hayao Miyazaki, Michiyo Yasuda mentioned that he changed the hues in detail in every scene according to emotional development.
                I thought about the nearly grey background here0 and decided if those colors were truly right. 
                Light, flowers, fire all at least have some essense of warmth or life - a warm background and more contrast lighting should help to bring that feeling out.
                I then tried to incorperate the common color schemes from the original animation into the background.
                <br><br>
                Another idea I (maybe) took from Studio Ghibli's Moving Castle is the dial - the mood of the door location changing in the movie was the exact effect I had in mind
                when considering a trigger for activating the spells. At first I thought of adding a moving particle emitter like a fairy which would pass through each card - although then there would be two
                movements on the screen which I didn't want.
                <br>

                <h3>Eighth Render</h3>
                <video controls width="80%;" src="witch-render-80001-0600.mp4"></video>
                <br><br>
                This was the first draft on my full composition. 
                During this render I had already begun working on the next iteration, making the shader for the blinking eye. This render was to
                test out color/lighting on the background, timing of the changes/dial switch, framing, and such.
                <br><br>
                My takeaways here were:
                <ul>
                    <li>Dial animation takes away from the climax of individual animations</li>
                    <li>Light could contrast more</li>
                </ul>

                <h3>Ninth Render</h3>
                <video controls width="80%;" src="witch-render-90001-0600.mp4"></video>
                <br><br>
                This was more along the right track.
                New takeaways form this render and tenth render:
                <ul>
                    <li>More contrast in lighting</li>
                    <li>Add in lighting from fire and light ball</li>
                    <li>Space out eye blinks more</li>
                    <li>Shade smooth edges on dial</li>
                    <li>Fix the fire shadow mode to 'alpha clip' (notice how it makes a small shadow on the plant card)</li>
                    <li>Bring out the colors in the ice more/ rotate the geometry to a more interesting angle</li>
                </ul>

                
            </div>
        </div>

        <!-- FOOTER -->
        <div class="footer">
            <div class="social-links">
                <a href = "https://www.artstation.com/silvrhat/profile" target="_blank">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 75.29 68.46"><path d="M7162.88,7218.5a.87.87,0,0,0-.78,1.25c1.79,3.59,6.4,13.75,12.4,13.75H7217a.86.86,0,0,0,.74-1.31l-8-13.27a.86.86,0,0,0-.74-.42Z" transform="translate(-7162.01 -7165.04)" style="fill:#fff"/><path d="M7192.13,7166.6l37.73,65.79a.8.8,0,0,0,1.35,0c2.11-3.29,8.29-10.93,5.29-17.93-1.76-4.11-23.65-41.47-26-45-4-6-14.08-4.28-17.74-4.08A.79.79,0,0,0,7192.13,7166.6Z" transform="translate(-7162.01 -7165.04)" style="fill:#fff"/><path d="M7169,7206.5h31.91a.9.9,0,0,0,.78-1.35l-16.41-28.27a.9.9,0,0,0-1.57,0l-15.5,28.26A.9.9,0,0,0,7169,7206.5Z" transform="translate(-7162.01 -7165.04)" style="fill:#fff"/></svg></a>
                <a href = "https://github.com/SilvRHat" target="_blank">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 59.75 66.55"><path d="M7188.5,7241.12V7232a.38.38,0,0,0-.45-.37c-2,.4-10.21,1.58-13.55-5.1-3-6-3.17-4.17-6-7a3.1,3.1,0,0,1-1-2s0-4,5,0,4,5,7,7c2.61,1.74,7.48,1.21,8.71,1a.37.37,0,0,0,.32-.3c.24-1.4,2-5.74,3-5.74s-18.31-.06-20-17a20.94,20.94,0,0,1,4.8-15.79.36.36,0,0,0,0-.44c-.64-1-2.78-4.89.16-10.77,1-2,8.78,1.89,11.88,3.92a.32.32,0,0,0,.27,0c1.38-.32,12.38-2.74,21.71,0a.37.37,0,0,0,.27,0c1.21-.65,10.79-5.73,11.87-3.93,2.65,4.41.62,9.6.11,10.76a.38.38,0,0,0,.08.42c1.1,1.08,6.51,7.11,3.81,18.82-2.45,10.6-13,13.72-18.28,14a.38.38,0,0,0-.28.6,18.57,18.57,0,0,1,2.56,4.42c.91,2.72.17,14.47,0,16.65a.37.37,0,0,1-.37.35h-21.27A.38.38,0,0,1,7188.5,7241.12Z" transform="translate(-7167.5 -7174.95)" style="fill:#fff"/></svg></a>
                <a href = "https://www.linkedin.com/in/gavinzimmerman/" target="_blank">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 73.69 73.49"><path d="M7203.91,7236.13H7188.7v-49h14.58v6.49l.19.06c.12-.15.27-.29.38-.45a15.34,15.34,0,0,1,11.38-7.16,22.76,22.76,0,0,1,10.2.86c4.76,1.5,7.67,4.82,9.21,9.45a34.16,34.16,0,0,1,1.56,10.66c.07,9.49.05,19,.06,28.49a5.15,5.15,0,0,1-.06.62H7221V7235c0-8.08,0-16.15,0-24.23a30,30,0,0,0-.61-5.76c-.73-3.67-3-5.52-6.74-5.72-2.85-.15-5.46.41-7.36,2.75a10,10,0,0,0-2.06,5.44c-.16,1.63-.26,3.27-.26,4.9,0,7.56,0,15.12,0,22.68Z" transform="translate(-7162.57 -7162.64)" style="fill:#fff"/><path d="M7163.86,7187.1H7179v49h-15.15Z" transform="translate(-7162.57 -7162.64)" style="fill:#fff"/><path d="M7171.43,7162.64a8.84,8.84,0,1,1-8.86,8.84A8.81,8.81,0,0,1,7171.43,7162.64Z" transform="translate(-7162.57 -7162.64)" style="fill:#fff"/></svg></a>
                <a href = "mailto: gzimm4@gmail.com" target="_blank">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 116 80"><polyline points="9 9 58 40 106 10" style="fill:none;stroke:#fff;stroke-miterlimit:10;stroke-width:10px"/><rect x="5" y="5" width="106" height="70" style="fill:none;stroke:#fff;stroke-miterlimit:10;stroke-width:10px"/></svg></a>
                <a href = "https://silvrship.dev/" target="_blank">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 124 62"><path d="M7178.92,7230.5h-9.42a31,31,0,0,1,0-62h9.82v15h-9.82a16,16,0,0,0,0,32h9.42v15Z" transform="translate(-7138.5 -7168.5)" style="fill:#fff"/><path d="M7231.5,7230.5h-13v-15h13a16,16,0,0,0,0-32h-13.4v-15h13.4a31,31,0,0,1,0,62Z" transform="translate(-7138.5 -7168.5)" style="fill:#fff"/><path d="M7231.5,7207h-65v-15h65Z" transform="translate(-7138.5 -7168.5)" style="fill:#fff"/></svg></a>
            </div>
            <div class="project-links">
                <a href="../do-witchcraft/">Do Witchcraft</a>
                <a href="../Ukiyo/">Project::Ukiyo「浮世」</a>
                <!--<a href="../Portfolio/Ramen/">Tech·Katsu:Ramen</a>-->
                <a href="../grav-flux/">Gr@v:f/UX</a>
                <a href="../blackhole/">BlackH01e</a>
                <a href="../SPdr/">SP//dr_wbs</a>
                <a href="../MvRE/">Mv:RE(Rendering Engine)</a>
            </div>
        </div>

    </body>
</html>