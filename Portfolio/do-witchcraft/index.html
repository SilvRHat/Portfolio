<!--
    Welcome to my website!
    If you're seeing this message on the dev console, 
    then you must be here to find which font I used.
    Feel free to grab that right below :D
    - Gavin_

    Hosted at: github.com/SilvRHat/gzimm4.github.io
-->
<!DOCTYPE html>
<html>
    <head>
        <title>Do Witchcraft</title>
        <link rel="icon" href="../../favicon.ico">
        <link rel="stylesheet" href="../../style.css">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300&family=Noto+Serif+JP:wght@300;400&family=Shippori+Mincho&display=swap" rel="stylesheet">
    </head>
    <body>
        <!-- HEADER -->
        <div class="navbar">
            <a class="home" href="../..">
                <h1>Gavin Zimmerman<img class='logo' src="../../img/logo.png"></h1>
                <h2>Technical Art · Direction // Programming</h2>
            </a>
            <div class="content">
                <div class="dropdown">
                    <a href=""><h3>Tech Art</h3></a>
                    <div class="dropdown-content">
                        <a href="../do-witchcraft/">Do Witchcraft</a><br>
                        <a href="../Ukiyo/">Project::Ukiyo「浮世」</a><br>
                        <a href="../grav-flux/">Gr@v:f/UX</a><br>
                        <a href="../blackhole/">BlackH01e</a><br>
                        <a href="../SPdr/">SP//dr_wbs</a><br>
                        <a href="../Ramen/">Tech·Katsu:Ramen</a><br>
                    </div>
                </div>
                <div class="dropdown">
                    <a href=""><h3>Project</h3></a>
                    <div class="dropdown-content">
                        <a href="../MvRE/">Mv:RE(Rendering Engine)</a><br>
                        <a href="../noir/">Noir~ Game</a><br>
                        <a href="../Diced/">Diced</a><br>
                        <a href="../light-stealer/">Light Stealer</a><br>
                    </div>
                </div>
                <div class="dropdown">
                    <a href="../../Profile/"><h3>Profile</h3></a>
                </div>
                <div class="dropdown">
                    <a href="../../Archive/"><h3>Archive</h3></a>
                </div>
            </div>
        </div>

        <!-- COVER -->
        <div class="cover-fit">
            <img src="cover.png">
            <div class="vert_title">
                <h2 style="color:white;">Do Witchcraft</h2>
            </div>
        </div>


        <!-- MAIN -->
        <div class="scroll">
            <!-- youtube -->
            <div class="content-2">
                <div class="info-box">
                    <h2>Do Witchcraft</h2>
                    <img><br>

                    <table style="text-align: center; margin: auto;">
                        <tr>
                            <td><strong>People:</strong></td>
                            <td><small>Gavin Zimmerman</small></td>
                        </tr>
                        <tr>
                            <td><strong>Timeline:</strong></td>
                            <td><small>May 2022 - June 2022</small></td>
                        </tr>
                        <tr>
                            <td><strong>Media:</strong></td>
                            <td><small>Realtime VFX</small></td>
                        </tr>
                        <tr>
                            <td><strong>Tech:</strong></td>
                            <td><small>Blender 3.2</small></td>
                        </tr>
                        <tr>
                            <td><strong>Link:</strong></td>
                            <td><small>N/A</small></td>
                        </tr>
                    </table>

                    <h3>Table of Contents</h3>
                    <ul>
                        <li><a href="#project">Do Witchcraft</a>
                            <ul>
                                <li><a href="#video">Video</a></li>
                                <li><a href="#about">About</a></li>
                            </ul>
                        </li>
                        <li><a href="#breakdown">Breakdown</a>
                            <ul>
                                <li><a href="#vfx">VFX Storyboards</a></li>
                                <li><a href="#material">Material Shaders</a>
                                    <ul>
                                        <li><a href="#mat-eye">Eye</a></li>
                                        <li><a href="#mat-ice">Ice</a></li>
                                        <li><a href="#mat-flower">Flower</a></li>
                                        <li><a href="#mat-fire">Fire</a></li>
                                    </ul>
                                </li>
                                <li><a href="#glyphs">Glyph Shaders</a></li>
                                <li><a href="#anim-set">Animation Setup</a></li>
                                <li><a href="#anim">Procedural Geometry and Animation</a>
                                    <ul>
                                        <li><a href="#anim-light">Light</a></li>
                                        <li><a href="#anim-ice">Ice</a></li>
                                        <li><a href="#anim-flower">Flower</a></li>
                                        <li><a href="#anim-fire">Fire</a></li>
                                    </ul>
                                </li>
                                <li><a href="#render">Rendering</a></li>
                            </ul>
                        </li>
                    </ul>
                </div>
                <h1 id="project">Do Witchcraft</h1>
                <div id="video" class="project-reel">
                    <iframe style="aspect-ratio: 560/315; width: 100%;" src="https://www.youtube.com/embed/_1Ni1kh8UYo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                </div>

                <h2 id="about">About</h2>
                Do Witchcraft is a personal project exploring SDFs, bezier curves, animation curves,
                procedural geometry, timing, and of course magic. The concept behind the magic spells is taken from "The Owl House"
                animation series by Dana Terrace and produced by Disney Television Animation.
                <br><br>
                Each card contains a glyph/symbol on them responsible for performing a spell,
                with four base symbols for: light, ice, plant, and fire magic.
                <br><br>
                These effects are created entirely procedurally from modeling to animation to texturing. 

                <h1 id="breakdown">Breakdown</h1>
                As with all my projects, I've included a detailed breakdown behind the making of this animation.
                This writeup is a collection of design choices, technical methods, code, concept images, mathmatical notes and designs, and everything inbetween.
                <br><br>
                At the bottom is a new section on rendering workflow - describing what went wrong in early renders and how iterations built up the final animation here.
                <br><br>
                If you, as a reader, have any questions about the process or content here then please don't hesitate to ask.
                <br><br>


                <h2 id="vfx">VFX Storyboards</h2>

                <br><br>
                <img class="img-border" style="width:calc(45% - 10px);" src="img/light-st.png">
                <p class="img-id">1</p>
                <div style="display: inline-block; width: 5%;"></div>
                <img class="img-border" style="width:calc(45% - 10px);" src="img/ice-st.png">
                <p class="img-id">2</p>
                <br><br>
                <img class="img-border" style="width:calc(45% - 10px);" src="img/plant-st.png">
                <p class="img-id">3</p>
                <div style="display: inline-block; width: 5%;"></div>
                <img class="img-border" style="width:calc(45% - 10px);" src="img/fire-st.png">
                <p class="img-id">4</p>

                <ol>
                    <li>Storyboard/ Notes for Light Spell</li>
                    <li>Storyboard/ Notes for Ice Spell</li>
                    <li>Storyboard/ Notes for Plant Spell</li>
                    <li>Storyboard/ Notes for Fire Spell</li>
                </ol>

                Drawing quick storyboards for each effect proved to be very useful conceptualizing the work to be done.
                Each board includes components of the effect, a timing reference (primary action for animation), and initial procedural design ideas.
                <br>
                Not all initial ideas (such as particles on the flower) made it into the final version, nor did the final version only have initial ideas.

                <h2 id="material">Material Shaders</h2>
                <img style="width: 99%;" src="img/materials.png">
                <p class="img-id">1</p>
                <br><br>

                There are a total of 15 shaders for the background, magic cards, eyeball dial thing, and elemental materials.
                This section covers the making of those elemental materials and the eyeball. I also reference notes on geometry,
                as geometric shape plays an important part in each material - they are not simply UV dependent.
                
                <h3 id="mat-eye">Eyeball</h3>
                The dial object with the eyeball printed on it wasn't thought of until halfway through the formal rendering process. In fact,
                it was completely coded while another computer was working on the latest render to see if the concept would even fit.
                <br><br>
                The shader setup is relatively simple, two principled BSDFs (Blender's PBR shader) were mixed together by a "blinking" factor (boolean). 
                These BSDF's were configured to look like metal and an eyeball by adjusting specular, metallic, clearcoat, roughness, and emissive parameters.
                <br><br>
                <img style="width: 35%;" src="img/metal-nd.png">
                <p class="img-id">2</p>
                <img style="width: 61%;" src="img/eye-nd.png">
                <p class="img-id">3</p>
                <br><br>
                <ol>
                    <li>Materials on Sphere</li>
                    <li>Metal Shader</li>
                    <li>Eyeball Shader</li>
                </ol>

                For simplicity, the blinking animation is driven by the frame number. 
                The animation started off as periodic, where the frame was divided by the frequency (frames per blink). 
                The fraction component of this value has then shaped like an absolute triangle wave, and then into thin spikes. 
                This was used as a space multiplier, which is then passed into a 3D space multiplier which affects the result of a length comparison which is then used as the factor.
                1D voronoi noise is added so to the frame input to offset each blink into a semi-random cycle. 
                <br><br>
                <img style="width: 99%;" src="img/blink-nd.png">
                <p class="img-id-side">4</p>
                <img style="width: 99%;" src="img/blink2-nd.png">
                <p class="img-id-side">5</p>
                <br><br>
                <ol start="4">
                    <li>Shaping Time into blink signals; final power node is number of units to multiply X-axis space by</li>
                    <li>Checking length to shape eyelids; note maximum is used such that if the blink signal is at its max value then all everything is eyelid</li>
                    <li>Light parented to eyeball for custom specular reflection</li>
                </ol>
                Finally, a small light was parented the the eye for the custom specular. 
                <br><br>
                <img style="width: 50%;" src="img/eye-spec.png">
                <p class="img-id">6</p>



                
                

                <h3 id="mat-ice">Ice</h3>
                The ice material makes some assumptions about the geometry - in that it expects the geometry to be shaded flat and for vertices to be sparse.
                <br><br>
                For the actual geometry, noise is added/subtracted along the normals of vertices on a detailed object. 
                The object is then tesselated to lower detail (and vertices).
                <br><br>

                As far as shading, the layers/blending get pretty fun here.
                <br><br>

                <img style="width: 24%;" src="img/ice-m1.png">
                <p class="img-id">1</p>
                <img style="width: 21%;" src="img/ice-m2.png">
                <p class="img-id">2</p>
                <img style="width: 51%;" src="img/ice-r-1-2.png">
                <p class="img-id">3</p>
                <br><br>
                <ol>
                    <li>The base color is driven by noise from the normal</li>
                    <li>Refraction color is blended with base color</li>
                    <li>Node network of 1 + 2</li>
                </ol>

                This covers the base diffuse color.
                For scratches and extra details, we'll blend in some distored wave texture with a fresnel.
                <br><br>
                <img style="width: 32%;" src="img/ice-ma.png">
                <p class="img-id">4</p>
                <img style="width: 32%;" src="img/ice-mb.png">
                <p class="img-id">5</p>
                <img style="width: 32%;" src="img/ice-mab.png">
                <p class="img-id">6</p>
                <br><br>
                <img style="width: 60%;" src="img/ice-ab-nd.png">
                <p class="img-id">7</p>
                <br><br>
                <ol start="4">
                    <li>Fresnel Blending Value</li>
                    <li>Distored Wave Texture</li>
                    <li>Fresnel on Distorted Wave</li>
                    <li>Node Setup</li>
                </ol>
                The fresnel effect is to emphasize the scratches on surfaces pointing away from the camera, as is the case
                in reality.
                <br><br>
                The final touches involve noding this scratched ice look into a shader which processes scene lighting info.
                The ice ejects from an emissive surface, so adding some emission at the bottom may be nice. Here, this emission
                is also multiplied with the value of the base color.
                <br><br>
                <img style="width: 23%;" src="img/ice-e1.png">
                <p class="img-id">8</p>
                <img style="width: 24%;" src="img/ice-e2.png">
                <p class="img-id">9</p>
                <img style="width: 50%;" src="img/ice-full-nd.png">
                <p class="img-id">10</p>
                <br><br>
                <ol start="8">
                    <li>Value derived from up axis</li>
                    <li>Emission</li>
                    <li>Full Node Tree</li>
                </ol>

                <h3 id="mat-flower">Flower; Stem, Leaf, and Petal</h3>
                The flower materials unlike the others are UV driven materials, 
                meaning that instead of 3D coordinates a 2D UV Map is required here. 
                This is important to point out, because it can be difficult to reuse these materials across multiple objects.
                Yet, that isn't a concern here as leaves generally look alike (and we're not in a production environment).
                <br><br>
                The most difficult bit with these materials is color and lighting. 
                It's really something you need to go outside and study and maybe draw a brief sketch to feel out the colors.<br><br>
                <img style="width: 50%;" src="img/plant-color-study.png">
                <p class="img-id">1</p>
                <br><br>
                <ol>
                    <li>Color Study</li>
                </ol>
                Similar to human skin, plants have layers of material which are translucent or semi-transparent. 
                Light passes through these layers, bounces, a while, and exits which is known as subsurface scattering.
                
                
                <br><br>
                <img style="width: 35.5%;" src="img/no-ss.png">
                <p class="img-id">2</p>
                <img style="width: 40%;" src="img/ss.png">
                <p class="img-id">3</p>
                <br><br>
                <ol start="2">
                    <li>Without Subsurface Scattering</li>
                    <li>With Subsurface Scattering</li>
                </ol>
                Notice that the shadows are much softer in subsurface scattering. 
                By altering which color is allowed to pass best through subsurface scattering, this smooth taper can have a color gradient.
                The detault is set to a reddish hue, however here I found that a blue green one to best reflect what I observed in nature.
                
                For the details on the leaf, it is largely shuffling with the UV map space. 
                X and Y make up the depth and width of the leaf respectively. 
                Rotating this space toward the center, provides a useful coordinate system for the veins of the leaf. 
                <br><br>
                <img style="width: 18%;" src="img/leaf1.png">
                <p class="img-id">4</p>
                <img style="width: 18%;" src="img/leaf2.png">
                <p class="img-id">5</p>
                <img style="width: 18.5%;" src="img/leaf3.png">
                <p class="img-id">6</p>
                <img style="width: 19%;" src="img/leaf4.png">
                <p class="img-id">7</p>
                <img style="width: 19%;" src="img/leaf5.png">
                <p class="img-id">8</p>
                <br><br>
                <img style="width: 70%;" src="img/voronoi-secret.png">
                <p class="img-id">9</p>
                <br><br>
                <ol start="4">
                    <li>Rotated Space with Voronoi for distance from vein</li>
                    <li>SDF from Stem</li>
                    <li>Smooth Minnimum of 4 and 5</li>
                    <li>Remapped Values</li>
                    <li>Value mapped to Color Ramp</li>
                    <li>Nodes for getting vein SDF</li>
                </ol>

                The petals are similar, but are naturally less patterned. 
                This setup is relatively small and although maybe lacking an eloquent method, matches detail with the rest of the scene and fits within the color scheme.
                <br><br>

                <img style="width: 24.1%;" src="img/petal1.png">
                <p class="img-id">10</p>
                <img style="width: 24.5%;" src="img/petal2.png">
                <p class="img-id">11</p>
                <img style="width: 23%;" src="img/petal3.png">
                <p class="img-id">12</p>
                <img style="width: 23%;" src="img/petal4.png">
                <p class="img-id">13</p>
                <br><br>
                <img style="width: 97.5%;" src="img/petal-nd.png">
                <p class="img-id">14</p>
                <br><br>
                <ol start="10">
                    <li>Noise</li>
                    <li>Voronoi with noise added onto coordinates</li>
                    <li>Remapped values for greater contrast</li>
                    <li>Color Ramp</li>
                    <li>Full shader tree for petals</li>
                </ol>

                <h3 id="mat-fire">Fire</h3>
                The ways for making fire are limitless.<br><br>
                The most common approach involves passing in some fire texture to a particle emitter and shaping the particles motion path
                to look like fire. 
                There are also fire simulation technology similar to fluid simulation- which might use a volume or surface shading technique.
                <br><br>
                This approach however assumes the geometry for our fire is a mesh (mostly) in the shape of fire. 
                For this section, I will use a sphere to breakdown the fragment shader.
                <br><br>
                To create this fire visual, I especially wanted to recreate the look of calcifer from Howl's Moving Castle by Studio Ghibli.
                I imagined this would pair well with the existing animations which had all already been completed.
                <br><br>
                <img style="width: 60%;" src="https://c.tenor.com/o7St1LoMu1MAAAAC/calcifer-studio-ghibli.gif">
                <p class="img-id">1</p>
                <img style="width: 34%;" src="img/fire-study.png">
                <p class="img-id">2</p>
                <br><br>
                <ol>
                    <li>Calcifer</li>
                    <li>Color/blending study</li>
                </ol>
                A key component in fire is the tendrils which move up along the edge of the shape. 
                This is actually very difficult to create well in a 3D setting opposed to a 2D setting, due to variation in perpsective.
                However, a custom fresnel effect and some noise can get pretty close to creating the effect.
                <br><br>
                <img style="width: 19%;" src="img/fire1.png">
                <p class="img-id">3</p>
                <img style="width: 19%;" src="img/fire2.png">
                <p class="img-id">4</p>
                <img style="width: 19%;" src="img/fire3.png">
                <p class="img-id">5</p>
                <img style="width: 19%;" src="img/fire4.png">
                <p class="img-id">6</p>
                <img style="width: 19%;" src="img/fire5.png">
                <p class="img-id">7</p>
                <br><br>
                <img style="width: 50%;" src="img/fire-alpha.gif">
                <p class="img-id">8</p>
                <br><br>
                <ol start="3">
                    <li>Normal</li>
                    <li>Normal blended with driven noise</li>
                    <li>Fresnel with new normal (dot with camera)</li>
                    <li>Remapped values</li>
                    <li>Flipped values/ Remapped More</li>
                    <li>Noise moves along Z (up) axis, to drive the tendrils up</li>
                </ol>

                This mask is now the alpha value or transparency of the fire. 
                And the same trick is used for each layer of color, using different mixes of noise. 
                The middle color barely mixes any noise into the normal. 
                I also plugged in an exponent operation here to customize the falloff of the fresnel effect.
                <br><br>
                <img style="width: 22%;" src="img/fire-orangered.png">
                <p class="img-id">9</p>
                <img style="width: 23%;" src="img/fire-yellow.png">
                <p class="img-id">10</p>
                <img style="width: 50%;" src="img/fire-bd.png">
                <p class="img-id">11</p>
                <br><br>
                <ol start="9">
                    <li>Blend between Dark Red/Pink (Outer) and Orange (Middle)</li>
                    <li>Yellow (Inner)</li>
                    <li>Node Breakdown</li>
                    <li>Blended Colors</li>
                    <li>Color with Transparency</li>
                </ol>
                Working with the colors here required a live render/viewing with the final shader output which was responsible for emission.
                Emission would blow up the darker colors to brighter and more contrast values- so getting this right required a bit of fine tuning.
                <br><br>
                <img style="width: 40%;" src="img/fire-color.gif">
                <p class="img-id">12</p>
                <img style="width: 46%;" src="img/fire-mat.gif">
                <p class="img-id">13</p>

                <h2 id="glyphs">Glyph Shaders</h2>
                <img style="width: 99%;" src="img/sdf.png">
                <p class="img-id">1</p>
                <br><br>
                Creating the glyphs on each card employed the use of custom SDFs (signed distance fields). 
                "Atomic" or basic SDFs such as for circles, lines, triangles, rectangles, and quadratic bezier lines were joined to produce the complete glyph.
                <br><br>
                <img style="width: 11%;" src="img/sdf1.png">
                <p class="img-id">2</p>
                <img style="width: 11%;" src="img/sdf2.png">
                <p class="img-id">3</p>
                <img style="width: 11%;" src="img/sdf3.png">
                <p class="img-id">4</p>
                <img style="width: 11%;" src="img/sdf4.png">
                <p class="img-id">5</p>
                <img style="width: 11%;" src="img/sdf5.png">
                <p class="img-id">6</p>
                <img style="width: 11%;" src="img/sdf6.png">
                <p class="img-id">7</p>
                <img style="width: 11%;" src="img/sdf7.png">
                <p class="img-id">8</p>
                <img style="width: 11%;" src="img/sdf8.png">
                <p class="img-id">9</p>
                <br><br>
                <ol start="2">
                    <li>Hollow Circle SDF [abs(Length-Radius)]</li>
                    <li>Line SDF</li>
                    <li>Another Line SDF</li>
                    <li>Rectangle SDF (w/ hard edges)</li>
                    <li>Quadratic Bezier SDF</li>
                    <li>2 Mirrored Line SDFs</li>
                    <li>Everything unioned via minimum operations</li>
                    <li>Colored</li>
                </ol>

                The full SDF trees were grouped (collapsed in a single node in Blender), 
                which allowed for reuse and abstracted away a large subprocess or subtree. 
                Translating the SDF into color was fairly easy using a compare operation with very small noise added for a pencil type effect.
                <br><br>

                <img style="width: 99%;" src="img/iceglyph-nd.png">
                <p class="img-id">10</p>
                <br><br>
                <ol start="10">
                    <li>Full Glyph Shader w/ SDFs grouped</li>
                </ol>
                Notice that framed section which is masked with the glyph outline and plugged into emission. This animates the emission changing over time.
                The setup uses to two remaps as inverse-lerp and lerp functions with a float curve in between to customize how values change. 
                The green node simply does nothing but organize the setup. As for the attribute labelled 'timeline', that will be covered in the next section.

                <h2 id="anim-set">Animation Setup</h2>
                <img style="width: 50%;" src="img/anim-setup.gif">
                <p class="img-id">1</p>
                <br><br>
                The attribute labeled timeline from above is driven by the Z position of an empty object per magic spell object.
                This tool proved to be a very useful method of animating as the procedural animations were not dependent on frames or the 'real' timeline.
                Retiming when each animation played and for how long could be easily controlled by adjusting the animation of the empty without changing any of the code which made up the geometry at any moment. 
                <br><br>
                A standard timeline also came out of this which timed each animation similarly over an abstract range of t=[-1,3] (or z=[2,-2]). 
                Around 2.8 was where most animations played the big transformation motion.
                <br><br>
                <img style="width: 99%;" src="img/timeline-nd.png">
                <p class="img-id">2</p>
                <ol>
                    <li>Animation driven by empty</li>
                    <li>Geometry Nodes calculating arbitrary time for animations</li>
                </ol>
                Mapping the empty's Z position to some time value happened in the geometry node setup. 
                This was because the geometry nodes which programmed how the animated geometry looked needed reference to the timeline as well.
                Geometry nodes are also able to output attributes which can then be read by the shader which was important for animating the emission property.
                
                <h2 id="anim">Procedural Geometry and Animation</h2>
                This section covers a breakdown on how the animations/models are created procedurally. 
                These node trees read slightly different than shaders, from the concept of fields explained very well by <a target="_blank" href="https://www.youtube.com/watch?v=8FCHcbpnFss">Erindale</a>.
                However, in this section I'm going to generally avoid showing/explaining in detail the nodes themselves - or this writeup would be LONG.

                <h3 id="anim-light">Light</h3>
                <img style="width: 99%;" src="img/light-gnd.png">
                <p class="img-id">1</p>
                <br><br>
                The general idea behind the light animation is to crumble a plane into a ball, move it upwards, and scale a sphere around it.
                
                <br><br>
                <img style="width: 30%;" src="img/light-wireframe.gif">
                <p class="img-id">2</p>
                <img style="width: 29.5%;" src="img/light-solid.gif">
                <p class="img-id">3</p>
                <br><br>
                <ol>
                    <li>Full Node Tree for Light</li>
                    <li>Wireframe View (Apologies on slow GIF)</li>
                    <li>Solid View</li>
                </ol>

                To achieve the crumbling effect, the plane was thought of in polar coordinates (azimuth angle and radius).
                With the radius as the x-axis and the 3D z-axis as the y-axis, a new 2D coordinate system allowed for a model which could curl in the edges.
                The crumbled position could be set in this 2D plane, and rotated back into its 3D position using the original azimuth angle.
                <br><br>
                <img style="width: 57%;" src="img/1d-crumble.gif">
                <p class="img-id">4</p>
                <img style="width: 37%;" src="img/crumble-model.png">
                <p class="img-id">5</p>
                <br><br>
                <ol start="4">
                    <li>Model Animated</li>
                    <li>Curling Model</li>
                </ol>
                Two parameters are being animated here, where the circle for curving is placed and how big the circle is. 
                Notice how at the beginning the curvature creates a smaller circle.

                <br><br>
                <img style="width: 44.5%;" src="img/2d-crumble.gif">
                <p class="img-id">6</p>
                <img style="width: 45.5%;" src="img/crumble-noise.gif">
                <p class="img-id">7</p>
                <br><br>
                <img style="width: 45.75%;" src="img/crumble-noise-float.gif">
                <p class="img-id">8</p>
                <img style="width: 44.25%;" src="img/crumble-sphere.gif">
                <p class="img-id">9</p>
                <br><br>
                <ol start="6">
                    <li>Rotating earlier 2D model into 3D space</li>
                    <li>Layering noise</li>
                    <li>Adding float</li>
                    <li>Adding sphere</li>
                    <li>Node Snippet</li>
                </ol>
                
                To complete the crumble look, noise is added in as a displacement. 
                Parameters for the noise are animated, specifically amplitude and distortion. 
                Afterwards, some animated value is added to the Z position and a sphere is scaled to replace the crumbled plane visual.
                <br><br>
                To give a preview of how this looks in code up close, the following image showcases time being plugged into similar node setups as the earlier glyph shader section to animate parameters which control the geometry.
                <br><br>
                <img style="width: 99%;" src="img/light-gnd-pr.png">
                <p class="img-id">10</p>

                <h3 id="anim-ice">Ice</h3>
                <img style="width: 99%;" src="img/ice-gnd.png">
                <p class="img-id">1</p>
                <br><br>
                The geometry for the ice already exists (3D modeled seperately).
                The core of how ice is animated is by cloning the instance of the existing ice model and then positioning it.
                Some noise is added to give the ice jut a bit more rigid feeling, like there is some resistence for sprouting up from the ground.
                <br><br>
                The fragment shader will then be in charge of properly clipping anything below the magic card. (This can also be done with clipping planes in OpenGL at the vertex processing stage rather than fragment stage as done here)
                <br><br>
                <ol>
                    <li>Full node tree</li>
                    <li>Solid View Perspective</li>
                </ol>
                <br><br>
                <img style="width: 30%;" src="img/ice-sprout.gif">
                <p class="img-id">2</p>


                <h3 id="anim-flower">Flower</h3>
                <img style="width: 99%;" src="img/flower-gnd-imtimidate.png">
                <p class="img-id">1</p>
                <br><br>
                Unlike the ice geometry which was rigid and could be cloned, the flower is the opposite and is completely generated from scratch.
                <br><br>
                Luckily the shape of every piece has consistent cross-sections (circle for stem and flat bended circle for petals and leaf). 
                So, to make this possible the geometry that gets animated are curves, which are then modeled into meshes with other curves acting as the cross-section profile.
                <br><br>
                <img style="width: 30%;" src="img/flower-noodle.gif">
                <p class="img-id">2</p>
                <br><br>
                <ol>
                    <li>Full Node Network</li>
                    <li>Fower as curves</li>
                    <li>Stem Curve Node Tree</li>
                </ol>
                Here, there are 4 different types of curves (stem, leaves, petal, and antenna). 
                For simplicity on the petal and leaves, only 1 curve is generated and then instanced and rotated around the tangent vector (along curve) of the stem curve.
                <br><br>
                The stem is fairly simple, as a simple line curve node is used. 
                A noise texture is then used to reposition each control point (no vertices for curves). 
                Some value X is animated over time, this value can be thought of as an offset for the noise. This allows noise to change over time in a non-linear fashion.
                <br><br>
                <img style="width: 99%;" src="img/stem-gnd.png">
                <p class="img-id">3</p>
                <br><br>
                Adding noise onto the existing position will offset the position where the stem grows from. 
                To correct, the result of noise given from the position at the bottom is subtracted from the noise given by the actual position.
                This is why there are two noise texture nodes here.
                <br><br>
                For the leaves, the motion should appear somewhat similar. 
                The curves for this use the exact same 2D model for curving the plane in the light animation. 
                A cubic bezier curve selects points along this model to produce a smoother version, which is used as the final leaf curve.
                <br><br>
                <img style="width: 44%;" src="img/leaf-model.gif">
                <p class="img-id">4</p>
                <img style="width: 45.5%;" src="img/leaf-model2.gif">
                <p class="img-id">5</p>
                <br><br>
                <ol start="4">
                    <li>Underlying Curve Model as before</li>
                    <li>Sampled Bezier Curve</li>
                </ol>
                A similar idea works for the petal. One smooth curve is generated, the space is rotated, and then instanced, and rotated for each petal to the correct final location.
                The number of animated parameters for this one is a bit larger, as a full quadratic bezier curve is animated with 3 animated control points and an animated ngle.
                <br><br>
                <img style="width: 99%;" src="img/petal-gnd.png">
                <p class="img-id">6</p>
                <ol start="6">
                    <li>Node network animating control points for petal curve</li>
                    <li>Petal Profile Node setup</li>
                </ol>
                Finally (skipping over some steps), the curves are all profiled using a network similar to the following. 
                The profile curve is a constant shape, but each control point along the original curve contains a radius attribute.
                This is used to set how large the profile should be when converting to a mesh.
                <br><br>
                <img style="width: 99%;" src="img/petal-profile.png">
                <p class="img-id">7</p>


                <h3 id="anim-fire">Fire</h3>
                <img style="width: 99%;" src="img/fire-gnd.png">
                <p class="img-id">1</p>
                Animating the paper for the fire had a similar implemntation as the light animation.
                Some noise displaces the paper for a wavy effect, it floats upward, and the transformation is scaled up to replace the paper.
                <br><br>
                One difference was that instead of fire being scaled over the magic paper, the magic paper dissolved by heat of the fire and went in all types of directions.
                This effect was achieved by first subdividing the plane once and splitting the mesh on its edges, which resulted in 4 mesh islands.
                The positions of the vertices from each island was then averaged to produce a (normalized) vector for the direction the island should travel along.
                <br><br>
                <img style="width: 54%;" src="img/fire-split.gif">
                <p class="img-id">2</p>
                <img style="width: 42%;" src="img/fire-split2.gif">
                <p class="img-id">3</p>
                <br><br>
                <ol>
                    <li>Full Node Tree</li>
                    <li>Along initial vector</li>
                    <li>Along animated vector</li>
                </ol>
                Since the flame took longer to reach the verticle ends, the paper had to be split in half first before the flame reached far enough to split again. 
                Do get this right, an additional animation parameter was added to multiple the X component of the vector noted above.
                <br><br>
                <img style="width: 45%;" src="img/fire-split3.gif">
                <p class="img-id">4</p>
                <img style="width: 48%;" src="img/fire-split4.gif">
                <p class="img-id">5</p>
                <br><br>
                <ol start="4">
                    <li>Noise added to direction vector</li>
                    <li>Noise added to vertice position</li>
                    <li>Torus Curve before profiling</li>
                </ol>

                The noise shown in picture 5 is similar to how the light paper was deformed. 
                This noise is also reused with the expanding torus. 
                <br><br>
                The torus is a circle curve profiled along another circle curve. 
                The radii of both are animated over time. 
                Before the curves are used to generate a mesh, the position of the curve (non-profile one) is offset using the noise mentioned above.
                <br><br>
                <img style="width: 60%;" src="img/torus-curve.gif">
                <p class="img-id">6</p>
                <br><br>

                The method I used here for making a mesh shaped like fire was initially the byproduct of random experimenting with asteroids on another project of mine.
                The trick is to use some 3D noise as displacement on a sphere and to move that noise along the Z axis. 
                You then use the initial Z (up) coordinates to scale how much noise is applied.
                <br><br>
                <img style="width: 28.5%;" src="img/fire-mesh0.png">
                <p class="img-id">7</p>
                <img style="width: 32%;" src="img/fire-mesh1.gif">
                <p class="img-id">8</p>
                <img style="width: 32%;" src="img/fire-mesh2.gif">
                <p class="img-id">9</p>
                <br><br>
                <img style="width: 30%;" src="img/fire-mesh3.gif">
                <p class="img-id">10</p>
                <img style="width: 31%;" src="img/fire-mesh4.gif">
                <p class="img-id">11</p>
                <img style="width: 32%;" src="img/fire-mesh5.gif">
                <p class="img-id">12</p>
                <br><br>
                <ol start="7">
                    <li>IcoSphere</li>
                    <li>Musgrave noise as displacement</li>
                    <li>Displacement scaling by initial Z position</li>
                    <li>Scaling Animation and Upward Positioning</li>
                    <li>Animating the scaling parameter on the 3D noise</li>
                    <li>Shading</li>
                </ol>

                Note the jump between pictures 10 and 11. 
                This was by animating the scaler for the noise, which is internally multiplied with the texture coordinate input.
                By changing this a little, the space of noise grows and shrinks which is used to make this effect. Because,
                the space itself is being multiplied by some factor, this is very dependent on the positions passed into the noise being close to zero.
                If that is not the case, then the positions change drastically.
                <br><br>
                Getting the detail for the fire was also quite difficult. 
                There needed to be enough detail so that the fire edges weren't visible, but there couldn't be too much detail that it was difficult to use a fresnel effect in the fragment shader.
                Thus, normals are taken at a lower-resolution and transferred to higher-detailed geometry.


                <h2 id="render">Rendering</h2>
                The timeline for this project largely put rendering towards the very end. 
                The majority of time was spent making each VFX look great in realtime and not until each effect was done had I thoroughly
                explored composition, layout, camera animation, background, etc. 
                Thus, rendering was in a short enough timeline that documenting a comprehensive outline on this iterative process was very easy.
                <br><br>
                Here I've compiled a run with most of the renders chronologically, some didn't change greatly and are omitted. 
                Below are sections on the takeaways of each render, mostly on what could be improved for the next render.

                <br><br>
                <iframe style="aspect-ratio: 560/315; width: 100%;" src="https://www.youtube.com/embed/IzlrGA7qJtI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                

                <h3>First Render</h3>
                Takeaways:
                <ul>
                    <li>The light is a bit overscaled compared to the other animations</li>
                    <li>The splash on the ice dissipates too quick</li>
                    <li>The stem color on the flower was too faded (same with leaf)</li>
                    <li>The subsurface radius/color clashed with the petal colors</li>
                    <li>Petals are overdetailed compared to other components</li>
                    <li>The edges on the fire had too much fade</li>
                    <li>The noise on the fire edges was too fine and the moving of this noise was too fast</li>
                </ul>
                <br>

                <h3>Second Render</h3>
                Takeaways:
                <ul>
                    <li>Shadows on light card are really not great during the crumble</li>
                    <li>Ice animation in now too long - notice flicker at end</li>
                    <li>The color here could also be stronger</li>
                    <li>The fire big explosion is a bit to fast</li>
                </ul>

                <h3>Third Render</h3>
                Takeaways:
                <ul>
                    <li>Ice splash is still wonky (doesn't fade soon enough this time)</li>
                    <li>Light animation is still a bit too large</li>
                </ul>

                <h3>Fifth Render</h3>
                After the fifth render, I was fairly happy with the effects and started working on camera animation and overall turning this into a video 
                for showcasing the animations as a collection. I also added a soft gradient to the background.
                <br><br>
                I really liked the spin and circular framing; which seemed to add anticipation from one effect to the next.
                <br><br>
                I then published this version to youtube, because I thought I hit the top as far what I could do. 
                But I wasn't very happy with this result - working with each animation individually had a lot of feeling and was very exciting to see come together. 
                Yet, together there wasn't much feeling in it. 
                The context of each animation in the environment as a whole was dull. Simply playing the animation wasn't enough,
                ultimately there had to exist a reason or context for it to play.
                <br><br>
                In the Art book of Howl's Moving Castle by Hayao Miyazaki, Michiyo Yasuda mentioned that he changed the color hues in every scene according to emotional development.
                I thought about the nearly grey background here and wondered if those colors were truly right - which had first seemed favorable for a demo/portfolio piece. <br><br>
                Light, flowers, fire all at least have some essense of warmth or life - a warm background and more contrast lighting should help to bring that feeling out.
                I then tried to incorperate the common color schemes from the original animation into the background.
                <br><br>
                I also decided to add some dial which would play with the animations, which would add some narrative.
                <br>

                <h3>Eighth Render</h3>
                During this render I had already begun working on the next iteration, making the shader for the blinking eye. This render was to
                test out color/lighting on the background, timing of the changes/dial switch, framing, and such.
                <br><br>
                Takeaways:
                <ul>
                    <li>Dial animation takes away from the climax of individual animations</li>
                    <li>Light could contrast more</li>
                </ul>

                <h3>Ninth + Tenth Renders</h3>
                Takeaways:
                <ul>
                    <li>More contrast in lighting</li>
                    <li>Add in lighting from fire and light ball</li>
                    <li>Space out eye blinks more</li>
                    <li>Shade smooth edges on dial</li>
                    <li>Fix the fire shadow mode to 'alpha clip' (notice how it makes a small shadow on the plant card)</li>
                    <li>Bring out the colors in the ice more/ rotate the geometry to a more interesting angle</li>
                </ul>
            </div>
        </div>

        <!-- FOOTER -->
        <div class="footer">
            <div class="social-links">
                <a href = "https://www.artstation.com/silvrhat/profile" target="_blank">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 75.29 68.46"><path d="M7162.88,7218.5a.87.87,0,0,0-.78,1.25c1.79,3.59,6.4,13.75,12.4,13.75H7217a.86.86,0,0,0,.74-1.31l-8-13.27a.86.86,0,0,0-.74-.42Z" transform="translate(-7162.01 -7165.04)" style="fill:#fff"/><path d="M7192.13,7166.6l37.73,65.79a.8.8,0,0,0,1.35,0c2.11-3.29,8.29-10.93,5.29-17.93-1.76-4.11-23.65-41.47-26-45-4-6-14.08-4.28-17.74-4.08A.79.79,0,0,0,7192.13,7166.6Z" transform="translate(-7162.01 -7165.04)" style="fill:#fff"/><path d="M7169,7206.5h31.91a.9.9,0,0,0,.78-1.35l-16.41-28.27a.9.9,0,0,0-1.57,0l-15.5,28.26A.9.9,0,0,0,7169,7206.5Z" transform="translate(-7162.01 -7165.04)" style="fill:#fff"/></svg></a>
                <a href = "https://github.com/SilvRHat" target="_blank">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 59.75 66.55"><path d="M7188.5,7241.12V7232a.38.38,0,0,0-.45-.37c-2,.4-10.21,1.58-13.55-5.1-3-6-3.17-4.17-6-7a3.1,3.1,0,0,1-1-2s0-4,5,0,4,5,7,7c2.61,1.74,7.48,1.21,8.71,1a.37.37,0,0,0,.32-.3c.24-1.4,2-5.74,3-5.74s-18.31-.06-20-17a20.94,20.94,0,0,1,4.8-15.79.36.36,0,0,0,0-.44c-.64-1-2.78-4.89.16-10.77,1-2,8.78,1.89,11.88,3.92a.32.32,0,0,0,.27,0c1.38-.32,12.38-2.74,21.71,0a.37.37,0,0,0,.27,0c1.21-.65,10.79-5.73,11.87-3.93,2.65,4.41.62,9.6.11,10.76a.38.38,0,0,0,.08.42c1.1,1.08,6.51,7.11,3.81,18.82-2.45,10.6-13,13.72-18.28,14a.38.38,0,0,0-.28.6,18.57,18.57,0,0,1,2.56,4.42c.91,2.72.17,14.47,0,16.65a.37.37,0,0,1-.37.35h-21.27A.38.38,0,0,1,7188.5,7241.12Z" transform="translate(-7167.5 -7174.95)" style="fill:#fff"/></svg></a>
                <a href = "https://www.linkedin.com/in/gavinzimmerman/" target="_blank">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 73.69 73.49"><path d="M7203.91,7236.13H7188.7v-49h14.58v6.49l.19.06c.12-.15.27-.29.38-.45a15.34,15.34,0,0,1,11.38-7.16,22.76,22.76,0,0,1,10.2.86c4.76,1.5,7.67,4.82,9.21,9.45a34.16,34.16,0,0,1,1.56,10.66c.07,9.49.05,19,.06,28.49a5.15,5.15,0,0,1-.06.62H7221V7235c0-8.08,0-16.15,0-24.23a30,30,0,0,0-.61-5.76c-.73-3.67-3-5.52-6.74-5.72-2.85-.15-5.46.41-7.36,2.75a10,10,0,0,0-2.06,5.44c-.16,1.63-.26,3.27-.26,4.9,0,7.56,0,15.12,0,22.68Z" transform="translate(-7162.57 -7162.64)" style="fill:#fff"/><path d="M7163.86,7187.1H7179v49h-15.15Z" transform="translate(-7162.57 -7162.64)" style="fill:#fff"/><path d="M7171.43,7162.64a8.84,8.84,0,1,1-8.86,8.84A8.81,8.81,0,0,1,7171.43,7162.64Z" transform="translate(-7162.57 -7162.64)" style="fill:#fff"/></svg></a>
                <a href = "mailto: gzimm4@gmail.com" target="_blank">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 116 80"><polyline points="9 9 58 40 106 10" style="fill:none;stroke:#fff;stroke-miterlimit:10;stroke-width:10px"/><rect x="5" y="5" width="106" height="70" style="fill:none;stroke:#fff;stroke-miterlimit:10;stroke-width:10px"/></svg></a>
                <a href = "https://silvrship.dev/" target="_blank">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 124 62"><path d="M7178.92,7230.5h-9.42a31,31,0,0,1,0-62h9.82v15h-9.82a16,16,0,0,0,0,32h9.42v15Z" transform="translate(-7138.5 -7168.5)" style="fill:#fff"/><path d="M7231.5,7230.5h-13v-15h13a16,16,0,0,0,0-32h-13.4v-15h13.4a31,31,0,0,1,0,62Z" transform="translate(-7138.5 -7168.5)" style="fill:#fff"/><path d="M7231.5,7207h-65v-15h65Z" transform="translate(-7138.5 -7168.5)" style="fill:#fff"/></svg></a>
            </div>
            <div class="project-links">
                <a href="../do-witchcraft/">Do Witchcraft</a>
                <a href="../Ukiyo/">Project::Ukiyo「浮世」</a>
                <!--<a href="../Portfolio/Ramen/">Tech·Katsu:Ramen</a>-->
                <a href="../grav-flux/">Gr@v:f/UX</a>
                <a href="../blackhole/">BlackH01e</a>
                <a href="../SPdr/">SP//dr_wbs</a>
                <a href="../MvRE/">Mv:RE(Rendering Engine)</a>
            </div>
        </div>

    </body>
</html>